<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vinyl Groove SVG Generator</title>
  <style>
    body { font-family: sans-serif; padding: 2em; background: #f0f0f0; }
    #svgPreview { width: 100%; height: 400px; border: 1px solid #ccc; margin-top: 1em; background: #fff; }
    label, select, input, button { margin: 0.5em 0; display: block; }
  </style>
</head>
<body>
  <h1>Vinyl Groove SVG Generator</h1>

  <label for="audioFile">Upload WAV File:</label>
  <input type="file" id="audioFile" accept="audio/wav">

  <label for="recordSize">Record Size:</label>
  <select id="recordSize">
    <option value="7">7 inch</option>
    <option value="10">10 inch</option>
    <option value="12" selected>12 inch</option>
  </select>

  <label for="cutoff">Low Pass Filter Cutoff (Hz):</label>
  <input type="number" id="cutoff" value="2500">

  <label for="splitCount">How many SVGs to split into?</label>
  <select id="splitCount">
    <option value="1">1</option>
    <option value="3">3</option>
    <option value="6">6</option>
  </select>

  <button id="previewAudio">Play Filtered Audio</button>
  <button id="generateBtn">Generate SVG</button>
  <div id="svgPreview"></div>
  <a id="downloadLink" style="display:none;">Download SVG</a>

  <script>
    let audioBuffer, filteredAudio;

    const fileInput = document.getElementById('audioFile');
    const recordSize = document.getElementById('recordSize');
    const cutoffInput = document.getElementById('cutoff');
    const generateBtn = document.getElementById('generateBtn');
    const previewBtn = document.getElementById('previewAudio');
    const downloadLink = document.getElementById('downloadLink');
    const svgPreview = document.getElementById('svgPreview');
    const splitCountInput = document.getElementById('splitCount');

    let audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    fileInput.onchange = async () => {
      const file = fileInput.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async (e) => {
        audioBuffer = await audioCtx.decodeAudioData(e.target.result);
        filteredAudio = applyFilters(audioBuffer.getChannelData(0), +cutoffInput.value, audioBuffer.sampleRate);
      };
      reader.readAsArrayBuffer(file);
    };

    previewBtn.onclick = () => {
      if (!filteredAudio) return alert("Upload and filter audio first.");
      const previewBuffer = audioCtx.createBuffer(1, filteredAudio.length, audioCtx.sampleRate);
      previewBuffer.copyToChannel(Float32Array.from(filteredAudio), 0);
      const source = audioCtx.createBufferSource();
      source.buffer = previewBuffer;
      source.connect(audioCtx.destination);
      source.start();
    };

    generateBtn.onclick = () => {
      if (!filteredAudio) return alert("Upload and filter audio first.");
      const recordInches = +recordSize.value;
      const splitCount = +splitCountInput.value;
      const parts = splitAudio(filteredAudio, splitCount);
      svgPreview.innerHTML = '';
      downloadLink.style.display = 'none';

      parts.forEach((part, idx) => {
        const svg = generateGrooveSVG(part, recordInches, idx);
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const dl = downloadLink.cloneNode();
        dl.href = url;
        dl.download = `vinyl_groove_part${idx + 1}.svg`;
        dl.textContent = `Download SVG Part ${idx + 1}`;
        dl.style.display = 'block';
        svgPreview.appendChild(dl);

        const inline = document.createElement('div');
        inline.innerHTML = svg;
        svgPreview.appendChild(inline);
      });
    };

    function applyFilters(data, cutoff, sampleRate) {
      const riaaFiltered = data.map((sample, i) => {
        // crude inverse RIAA: boost highs
        const freq = i / data.length * sampleRate;
        const boost = freq > 5000 ? 2.5 : freq > 1000 ? 1.5 : 1;
        return sample * boost;
      });
      return lowPassFilter(riaaFiltered, cutoff, sampleRate);
    }

    function lowPassFilter(data, cutoff, sampleRate) {
      const RC = 1.0 / (cutoff * 2 * Math.PI);
      const dt = 1.0 / sampleRate;
      const alpha = dt / (RC + dt);
      let output = [];
      output[0] = data[0];
      for (let i = 1; i < data.length; i++) {
        output[i] = output[i - 1] + (alpha * (data[i] - output[i - 1]));
      }
      return output;
    }

    function splitAudio(data, parts) {
      const len = Math.floor(data.length / parts);
      let split = [];
      for (let i = 0; i < parts; i++) {
        split.push(data.slice(i * len, (i + 1) * len));
      }
      return split;
    }

    function generateGrooveSVG(audioData, sizeInches, index) {
      const svgNS = "http://www.w3.org/2000/svg";
      const svgSize = 1500;
      const center = svgSize / 2;
      const spacing = 2; // spacing between grooves
      const scale = 200; // amplitude scale
      const totalGrooves = Math.floor((+sizeInches * 100 - 400) / spacing);

      let radius = +sizeInches * 25.4 / 2; // mm to px-ish for demo
      let path = "<path d='";
      let angle = 0;
      let thetaStep = (2 * Math.PI) / audioData.length;

      for (let i = 0; i < audioData.length; i++) {
        const modRadius = radius - (spacing * i / audioData.length);
        const r = modRadius + audioData[i] * scale;
        const x = center + r * Math.cos(angle);
        const y = center + r * Math.sin(angle);
        path += (i === 0 ? "M" : "L") + x.toFixed(2) + "," + y.toFixed(2) + " ";
        angle += thetaStep;
      }
      path += "' stroke='black' fill='none' stroke-width='0.2'/>";

      const svg = `<svg xmlns='${svgNS}' width='${svgSize}' height='${svgSize}' viewBox='0 0 ${svgSize} ${svgSize}'>` + path + `</svg>`;
      return svg;
    }
  </script>
</body>
</html>
